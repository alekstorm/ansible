#!/usr/bin/env python

from httplib import HTTPConnection
from socket import socket, AF_UNIX, SOCK_STREAM
from urlparse import urlparse
from xmlrpclib import Server, ServerProxy, Transport

def main():
    arg_spec = dict(
        group=dict(),
        update=dict(default='no', choices=['yes', 'no']),
        config=dict(),
        server_url=dict(default='http://localhost:9001/RPC2'), # TODO read from config file
        state=dict(required=True, choices=['present', 'started', 'restarted', 'stopped'])
    )

    module = AnsibleModule(argument_spec=arg_spec, supports_check_mode=True)

    # TODO
    class UnixStreamHTTPConnection(HTTPConnection):
        def connect(self):
            self.sock = socket(AF_UNIX, SOCK_STREAM)
            self.sock.connect(urlparse(server_url).path)

    class UnixStreamTransport(Transport):
        def make_connection(self, host):
            return UnixStreamHTTPConnection(server_url, 80)

    group = module.params['group']
    update = module.params['update'] == 'yes'
    config = module.params.get('config')
    state = module.params['state']
    server_url = module.params.get('server_url')
    username = module.params.get('username')
    password = module.params.get('password')

    parsed_url = urlparse(server_url)
    if parsed_url.scheme in ['http', 'https']:
        server = Server(server_url)
    elif parsed_url.scheme == 'unix':
        server = ServerProxy(server_url, transport=UnixStreamTransport())
    else:
        pass # TODO fail
    supervisor = server.supervisor

    added, changed_groups, removed = ([], [], []) if not update else supervisor.reloadConfig()[0]

    def exit(changed):
        module.exit_json(changed=changed, group=group if group is not None else '<all>',
            state=state, added_groups=added, changed_groups=changed_groups, removed_groups=removed)

    changed = False
    if not all([len(l) for l in (added, changed_groups, removed)]):
        changed = True
        if module.check_mode:
            exit(True)

    def stop(process, fatal=True):
        try:
            supervisor.stopProcessGroup(process)
        except Fault, e:
            if fatal:
                module.fail_json(msg="Error while stopping process group: %s" % process)

    for group in removed:
        stop(group, False)
        supervisor.removeProcessGroup(group)
    for group in changed_groups:
        if supervisor.getProcessInfo(group)['statename'] == 'RUNNING':
            stop(group)
        supervisor.removeProcessGroup(group)
        supervisor.addProcessGroup(group)
    for group in added:
        supervisor.addProcessGroup(group)

    def start(process, fatal=True):
        try:
            supervisor.startProcessGroup(process)
        except Fault, e:
            if fatal:
                module.fail_json(msg="Error while starting process group: %s" % process)

    if group is None:
        processes = supervisor.getAllProcessInfo()
    else:
        processes = [supervisor.getProcessInfo(group)]

    running = (process['statename'] == 'RUNNING' for process in processes)

    if state == 'started':
        if all(running) and not changed:
            exit(False)
        else:
            if module.check_mode:
                exit(True)

            for process in processes:
                if process['statename'] != 'RUNNING':
                    start(process)

    elif state == 'stopped':
        if any(running):
            if module.check_mode:
                exit(True)

            for process in processes:
                if process['statename'] == 'RUNNING':
                    stop(process)
        elif not changed:
            exit(False)

    elif state == 'restarted':
        if module.check_mode:
            exit(True)

        for process in processes:
            if process['statename'] == 'RUNNING':
                stop(process['group'], False)
            start(process['group'])

    else:
        module.fail_json(msg="Unrecognized state: %s" % state)

    exit(True)

# this is magic, see lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>

main()
